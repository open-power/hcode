/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: import/chips/p10/procedures/ppe/qme/qme_stop_exit.C $         */
/*                                                                        */
/* OpenPOWER EKB Project                                                  */
/*                                                                        */
/* COPYRIGHT 2018,2021                                                    */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

#include "qme.h"
#include "errlutil.h"
#include <fapi2.H>
#include <fapi2_target.H>

#include "p10_hcd_cache_poweron.H"
#include "p10_hcd_cache_reset.H"
#include "p10_hcd_cache_scan0.H"
#include "p10_hcd_cache_gptr_time_initf.H"
#include "p10_hcd_cache_repair_initf.H"
#include "p10_hcd_cache_arrayinit.H"
#include "p10_hcd_cache_initf.H"
#include "p10_hcd_cache_startclocks.H"
#include "p10_hcd_cache_scominit.H"
#include "p10_hcd_core_cache_scom_customize.H"

#include "p10_hcd_core_poweron.H"
#include "p10_hcd_core_reset.H"
#include "p10_hcd_core_scan0.H"
#include "p10_hcd_core_gptr_time_initf.H"
#include "p10_hcd_core_repair_initf.H"
#include "p10_hcd_core_arrayinit.H"
#include "p10_hcd_core_initf.H"
#include "p10_hcd_core_startclocks.H"
#include "p10_hcd_core_scominit.H"

#include "p10_hcd_core_timefac_to_pc.H"
#include "p10_hcd_core_shadows_enable.H"
#include "p10_hcd_core_startgrid.H"
#include "p10_hcd_core_vmin_disable.H"


extern QmeRecord G_qme_record;



void
qme_stop_report_pls_srr1(uint32_t core_target)
{
    uint32_t c_index        = 0;
    uint32_t c_loop         = 0;
    uint32_t c_end          = 0;
    uint32_t t_index        = 0;
    uint32_t t_end          = 0;
    uint32_t t_offset       = 0;
    uint32_t pls_end        = 0;
    uint32_t srr1_end       = 0;
    uint32_t act_stop_level = 0;
    uint32_t old_pls        = 0;
    uint32_t new_pls        = 0;
    uint32_t srr1           = 0;
    uint32_t pscrs          = 0;
    uint32_t esl            = 0;
    uint32_t local_data     = 0;

    PK_TRACE("Restore PSCDR.PLS+SRR1 back to actual level");

    for( c_end = 51, t_end = 3,  c_index = 0,
         c_loop = 8; c_loop > 0; c_loop = c_loop >> 1,
         c_end += 4, t_end += 16, c_index++ )
    {
        if ( ! (c_loop & core_target) )
        {
            continue;
        }

        act_stop_level = ( in32_sh(QME_LCL_SCDR) >> SHIFT64SH(c_end) ) & 0xF;
        local_data     = 0;

        /*DEBUG ONLY
                PK_TRACE("Core[%x] act_stop_level[%x] previous act_stop_level[%x]",
                         c_loop, act_stop_level, G_qme_record.c_act_stop_level[c_index]);
                G_qme_record.c_act_stop_level[c_index] = act_stop_level;
        */
        for( pls_end  = 3, srr1_end = 17, t_index = 0,
             t_offset = 0; t_offset < 16; t_offset += 4,
             pls_end += 4, srr1_end += 2, t_index++ )
        {
            pscrs = in32( ( QME_PSCRS | (c_loop << 16) | (t_offset << 4) ) );

            PK_TRACE("c_loop[%x] t_offset[%x] pscrs_addr[%x], pscrs_data[%x]",
                     c_loop, t_offset,
                     ( QME_PSCRS | (c_loop << 16) | (t_offset << 4) ),
                     pscrs);

#if POWER10_DD_LEVEL == 10
            old_pls = ( pscrs & BITS32(24, 4) ) >> SHIFT32(27);
#else
            old_pls = ( in64(QME_LCL_PLSR) >> SHIFT64( (t_end + t_offset) ) ) & 0xF;
#endif

            new_pls = ( act_stop_level > old_pls ) ? (act_stop_level) : (old_pls);
            /*DEBUG_ONLY
                        PK_TRACE("old_pls[%x] new_pls[%x] previous old_pls[%x] new_pls[%x]",
                                 old_pls, new_pls,
                                 G_qme_record.t_old_pls[c_index][t_index],
                                 G_qme_record.t_new_pls[c_index][t_index]);

                        G_qme_record.t_old_pls[c_index][t_index] = old_pls;
                        G_qme_record.t_new_pls[c_index][t_index] = new_pls;
            */
            // unless esl=0, srr1 = some_state_loss regardless stop_level
            srr1 = SOME_STATE_LOSS_BUT_NOT_TIMEBASE;
            esl = pscrs & BIT32(2);

            if( !esl )
            {
                srr1 = NO_STATE_LOSS;
            }

            local_data |= ( new_pls << SHIFT32( pls_end  ) );
            local_data |= ( srr1    << SHIFT32( srr1_end ) );

            // Due to special wakeup to stop11 can be done with esl = 0
            // especially with ipl cases where core start with esl = 0
            // print these info as possible debug aid, instead of check and panic
            PK_TRACE("DEBUG: Core|Thread[%x] act_stop_level[%x] PSCRS = %x with esl[%x]",
                     (c_loop << 8 | t_offset), act_stop_level, pscrs, esl);
        }

        out32( QME_LCL_CORE_ADDR_WR( QME_DCSR, c_loop ), local_data );
    }

    // Do this to make sure the PLS is checked in
    PK_TRACE("Polling for STOP_SHIFT_ACTIVE == 0 via QME_SCSR[47]");

    while( in32_sh( QME_LCL_CORE_ADDR_OR( QME_SCSR, core_target ) ) & BIT64SH(47) );
}


void
qme_stop_handoff_pc(uint32_t core_target, uint32_t& core_spwu)
{
    uint32_t core_done = 0;
    uint32_t core_mask = 0;
    uint32_t cisr1     = 0;
    //===============//

    wrteei(0);

    // ===============================
    /*
        // Action below will cause PC to enter stop0, where PC is allowed to wakeup immediately without Pm_exit.
        // Thus protect PC from doing so until we assert pm_exit
        PK_TRACE("Assert BLOCK_INTERRUPT to PC via SCSR[0]");
        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_OR, core_target ), BIT32(0) );

        // Workaround for HW527893 to force PM_STATE = 0 via function of this bit
        // Juan's logic is going to block further regular wakeup as for stop0
        // especially for QME not get notified for interrupts to running core.
        PK_TRACE("Pulse Entry_Limit via PCR_SCSR[2]");
        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_OR,    core_target ), BIT32(2) );
        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_CLEAR, core_target ), BIT32(2) );
    */

    if( G_qme_record.fused_core_enabled )
    {
        for( core_mask = 8; core_mask > 0; core_mask = core_mask >> 1 )
        {
            if ( core_target & core_mask )
            {
                cisr1 = in32_sh( QME_LCL_CORE_ADDR_OR( QME_CISR, core_mask ) );

                // No interrupt pending AND no special wakeup
                if( ( ! ( cisr1 & 0xA ) ) &&
                    ( ! ( core_spwu & core_mask ) ) )
                {
                    PK_TRACE_INF("Warning: No PC_INTR_PENDING or REG_WKUP_PRESENT on Core %x via QME_CISR[60,62]", core_mask);
                    G_qme_record.c_stop1_targets |= core_mask;
                }
            }
        }
    }

    //===============//

    // do not mess pm_exit for cache_only cores
    uint32_t core_wakeup = core_target & ~G_qme_record.c_cache_only_enabled;

    if( core_wakeup )
    {
        PK_TRACE("Core Waking up(pm_exit=1) via PCR_SCSR[1]");
        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_OR, core_wakeup ), BIT32(1) );

        PPE_WAIT_4NOP_CYCLES

        PK_TRACE("Polling for Core Waking up(pm_active=0) via QME_SSDR[12-15]");

        while( ( ( (~in32(QME_LCL_SSDR)) >> SHIFT32(15) ) & core_wakeup ) != core_wakeup );
    }

    //===============//

    PK_TRACE("Update STOP history: STOP exit completed, core ready");
    out32( QME_LCL_CORE_ADDR_WR( QME_SSH_SRC, core_target ), SSH_EXIT_COMPLETE );

    // HW527893
    //stopclocks will take pm_active and regular wakeup away from EINR via its fencing
    //startclocks will reassert EINR via its unfencing so phantom wakeup will be created to EISR
    //clear them here, and pm_active will be taking care of via pm_exit below
    //special wakeup shouldnt be affacted via fences.
    PK_TRACE("Clear EISR on Regular Wakeup for extra edge caused by fencing/unfencing between entry and exit");
    out32_sh(QME_LCL_EISR_CLR, ( (core_target << SHIFT64SH(43)) | (core_target << SHIFT64SH(47)) ) );

    PK_TRACE("Drop halt STOP override disable via PCR_SCSR[21]");
    out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_CLEAR, core_target ), BIT32(21) );

    //===============//

    if( ( core_done = ( core_spwu & core_target ) ) )
    {
        uint32_t c_mma_down = core_done & (~G_qme_record.c_mma_available);

        if( c_mma_down && G_qme_record.mma_modes_enabled == MMA_POFF_DYNAMIC )
        {
            qme_mma_stop_exit(c_mma_down);
        }

        PK_TRACE_INF("SX.0A: Cores[%x] Assert Special_Wakeup_Done via PCR_SCSR[16]", core_done);
        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_OR, core_done ), BIT32(16) );
        G_qme_record.c_special_wakeup_done |= core_done;
    }

    if( ( core_target = ( core_target & (~core_spwu) ) ) )
    {
        PK_TRACE_INF("SX.0B: Cores[%x] Drop PM_EXIT via PCR_SCSR[1]", core_target);
        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_CLEAR, core_target ), BIT32(1) );
    }

    core_spwu &= ~core_done;

    wrteei(1);

}



void
qme_stop_exit()
{
    QmeHeader_t* pQmeImgHdr = (QmeHeader_t*)(QME_SRAM_HEADER_ADDR);
    fapi2::Target < fapi2::TARGET_TYPE_PROC_CHIP > chip_target;
    fapi2::Target < fapi2::TARGET_TYPE_CORE |
    fapi2::TARGET_TYPE_MULTICAST, fapi2::MULTICAST_AND > core_target;
    fapi2::Target < fapi2::TARGET_TYPE_CORE |
    fapi2::TARGET_TYPE_MULTICAST, fapi2::MULTICAST_AND > core_scom_rest_target;
    fapi2::Target < fapi2::TARGET_TYPE_CORE |
    fapi2::TARGET_TYPE_MULTICAST, fapi2::MULTICAST_AND > core_not_eco;
    uint32_t c_not_eco = 0;

    if( G_qme_record.c_stop2_exit_targets )
    {
        qme_fault_inject(QME_PCSCR_STOP2_EXIT_FAULT_INJECT, G_qme_record.c_stop2_exit_targets);
        out32( QME_LCL_CORE_ADDR_WR(
                   QME_SSH_SRC, G_qme_record.c_stop2_exit_targets ), SSH_EXIT_IN_SESSION );
    }

    ///// [STOP3 EXIT EXPRESS] /////

    if( G_qme_record.c_stop3_exit_targets )
    {
        PK_TRACE_INF("WAKE3: Waking up Cores in STOP3[%x]", G_qme_record.c_stop3_exit_targets);

        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop3_exit_targets));

        //===============//

        MARK_TAG( G_qme_record.c_stop3_exit_targets, SX_CORE_VMIN_DISABLE )

#if POWER10_DD_LEVEL != 10

        qme_fault_inject(QME_PCSCR_STOP3_RVRM_POWON_FAULT_INJECT, G_qme_record.c_stop3_exit_targets);
        p10_hcd_core_vmin_disable(core_target);

#else

        // artifical delay to minic stop3 latency for 2us

        for(int i = 0; i < 1000; i++)
        {
            asm volatile ("tw 0, 0, 0");
        }

#endif

        MARK_TAG( G_qme_record.c_stop3_exit_targets, SX_CORE_VOLT_RESTORED )

        //===============//

        G_qme_record.c_stop3_reached &= (~G_qme_record.c_stop3_exit_targets);
        G_qme_record.c_stop3_exit_targets = 0;
    }

    ///// [STOP2 EXIT EXPRESS] /////

    G_qme_record.c_stop2_exit_express =
        G_qme_record.c_stop2_exit_targets  &
        (~G_qme_record.c_stop5_exit_targets) &
        (~G_qme_record.c_stop11_exit_targets);

    if( G_qme_record.c_stop2_exit_express )
    {
        PK_TRACE_INF("FAST2: Express Waking up Cores in STOP2[%x]", G_qme_record.c_stop2_exit_express);

        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop2_exit_express));

        //===============//

        MARK_TAG( G_qme_record.c_stop2_exit_express, SX_CORE_SKEWADJUST )

        wrteei(0);
        p10_hcd_core_startgrid(core_target);

        //===============//

        MARK_TAG( G_qme_record.c_stop2_exit_express, SX_CORE_STARTCLOCKS )

        p10_hcd_core_startclocks(core_target);

        if( G_qme_record.mma_modes_enabled != MMA_POFF_DYNAMIC )
        {
            G_qme_record.c_mma_available |= G_qme_record.c_stop2_exit_targets;
        }

        wrteei(1);

        //===============//

        MARK_TAG( G_qme_record.c_stop2_exit_express, SX_CORE_ENABLE_SHADOWS )

        p10_hcd_core_shadows_enable(core_target);

        MARK_TAG( G_qme_record.c_stop2_exit_express, SX_CORE_CLOCKED )

        //===============//

        MARK_TAG( G_qme_record.c_stop2_exit_express, SX_CORE_HANDOFF_PC )

        p10_hcd_core_timefac_to_pc(core_target);

        //===============//

        qme_stop_report_pls_srr1(G_qme_record.c_stop2_exit_express);

        qme_stop_handoff_pc(G_qme_record.c_stop2_exit_express,
                            G_qme_record.c_special_wakeup_exit_pending);

        MARK_TAG( G_qme_record.c_stop2_exit_express, SX_CORE_AWAKE )

        //===============//

        G_qme_record.c_stop2_reached      &= (~G_qme_record.c_stop2_exit_express);
        G_qme_record.c_stop2_exit_targets &= (~G_qme_record.c_stop2_exit_express);

        PK_TRACE_INF("FAST2: Completed Waken up Cores from STOP2[%x], Updated Cores still in STOP2+[%x], Updated Cores still waking up[%x]",
                     G_qme_record.c_stop2_exit_express,
                     G_qme_record.c_stop2_reached,
                     G_qme_record.c_stop2_exit_targets);
    }

    ///// [STOP11 EXIT] /////

    if( G_qme_record.c_stop11_exit_targets )
    {
        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop11_exit_targets));

        //===============//

        // IF QMCR.MIXED_LPAR_MODE_DISABLE == 0
        if(! ( in32_sh(QME_LCL_QMCR) & BIT64SH(36) ) )
        {
            // Read QME Scratch B[20:23] and mask for core X
            // In fused core mode, ME Hcode will only key off of the even core bits (20, 22)
            // to manage the respective odd core too.
            G_qme_record.c_lpar_mode_enabled = ( in32(QME_LCL_SCRB) &
                                                 BITS32(QME_SCRB_CORE_LPAR_MODE_VECTOR_BASE,
                                                         QME_SCRB_CORE_LPAR_MODE_VECTOR_SIZE) ) >>
                                               SHIFT32( ( QME_SCRB_CORE_LPAR_MODE_VECTOR_BASE +
                                                       QME_SCRB_CORE_LPAR_MODE_VECTOR_SIZE - 1 ) );

            PK_TRACE_INF("WAKE11: Waking up Cores in LPAR mode[%x] under fused core mode[%x]",
                         G_qme_record.c_lpar_mode_enabled,
                         G_qme_record.fused_core_enabled);

            uint32_t fuse_mask = 0;

            // Write value from masked QME Scratch B[20:23] to SCSR[31] for Core X (if fused, Core X+1 too)
            // this establishes the LPAR mode wire to the core(s) and caches(s)
            for( uint32_t core_mask = 8; core_mask; core_mask = core_mask >> 1 )
            {
                if( core_mask & G_qme_record.c_lpar_mode_enabled & G_qme_record.c_stop11_exit_targets )
                {
                    if( G_qme_record.fused_core_enabled && (core_mask & 0xA) )
                    {
                        fuse_mask = core_mask | (core_mask >> 1);
                        core_mask = core_mask >> 1;
                        PK_TRACE_INF("fused: Set SCSR[31] Signle_Lpar_mode on core_mask[%x]", core_mask);
                        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_OR, fuse_mask ), BIT32(31) );
                    }
                    else
                    {
                        PK_TRACE_INF("Set SCSR[31] Signle_Lpar_mode on core_mask[%x]", core_mask);
                        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_OR, core_mask ), BIT32(31) );
                    }
                }
                else if( core_mask & G_qme_record.c_stop11_exit_targets )
                {
                    if( G_qme_record.fused_core_enabled && (core_mask & 0xA) )
                    {
                        fuse_mask = core_mask | (core_mask >> 1);
                        core_mask = core_mask >> 1;
                        PK_TRACE_INF("Fused: Clear SCSR[31] Signle_Lpar_mode on core_mask[%x]", core_mask);
                        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_CLEAR, fuse_mask ), BIT32(31) );
                    }
                    else
                    {
                        PK_TRACE_INF("Clear SCSR[31] Signle_Lpar_mode on core_mask[%x]", core_mask);
                        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_CLEAR, core_mask ), BIT32(31) );
                    }
                }
            }
        }

        //===============//

        // IF QMCR.MIXED_LPAR_MODE_DISABLE == 0
        if(! ( in32_sh(QME_LCL_QMCR) & BIT64SH(36) ) )
        {
            // Read QME Scratch B[20:23] and mask for core X
            // In fused core mode, ME Hcode will only key off of the even core bits (20, 22)
            // to manage the respective odd core too.
            G_qme_record.c_lpar_mode_enabled = ( in32(QME_LCL_SCRB) & BITS32(20, 4) ) >> SHIFT32(23);

            PK_TRACE_INF("WAKE11: Waking up Cores in LPAR mode[%x] under fused core mode[%x]",
                         G_qme_record.c_lpar_mode_enabled,
                         G_qme_record.fused_core_enabled);

            // Write value from masked QME Scratch B[20:23] to SCSR[31] for Core X (if fused, Core X+1 too)
            // this establishes the LPAR mode wire to the core(s) and caches(s)
            for( uint32_t core_mask = 8; core_mask; core_mask = core_mask >> 1 )
            {
                if( core_mask & G_qme_record.c_lpar_mode_enabled & G_qme_record.c_stop11_exit_targets )
                {
                    out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_OR, core_mask ), BIT32(31) );

                    if( G_qme_record.fused_core_enabled && (core_mask & 0xA) )
                    {
                        core_mask = core_mask >> 1;
                        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_OR, core_mask ), BIT32(31) );
                    }
                }
                else if( core_mask & G_qme_record.c_stop11_exit_targets )
                {
                    out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_CLEAR, core_mask ), BIT32(31) );

                    if( G_qme_record.fused_core_enabled && (core_mask & 0xA) )
                    {
                        core_mask = core_mask >> 1;
                        out32( QME_LCL_CORE_ADDR_WR( QME_SCSR_WO_CLEAR, core_mask ), BIT32(31) );
                    }
                }
            }
        }

        //===============//

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_POWERON )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_PFET_CTRL_ENABLE )
        {
#endif
            qme_fault_inject(QME_PCSCR_STOP11_POWON_FAULT_INJECT, G_qme_record.c_stop11_exit_targets);
            p10_hcd_cache_poweron(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        //===============//

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_RESET )

        wrteei(0);
        p10_hcd_cache_reset(core_target);

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_SCANFLUSH_ENABLE )
        {
#endif
            p10_hcd_cache_scan0(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_POWERED )

        //===============//

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_GPTR_TIME_INITF )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_SCAN_INIT_ENABLE )
        {
#endif
            p10_hcd_cache_gptr_time_initf(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        //===============//
        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop11_exit_targets));

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_REPAIR_INITF )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_SCAN_INIT_ENABLE )
        {
#endif
            p10_hcd_cache_repair_initf(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        if( !G_qme_record.c_stop11_exit_targets )
        {
            return;
        }

        //===============//
        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop11_exit_targets));

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_ARRAYINIT )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_ARRAYINIT_ENABLE )
        {
#endif
            p10_hcd_cache_arrayinit(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        if( !G_qme_record.c_stop11_exit_targets )
        {
            return;
        }

        //===============//

        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop11_exit_targets));
        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_INITF )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_SCAN_INIT_ENABLE )
        {
#endif
            p10_hcd_cache_initf(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        if( !G_qme_record.c_stop11_exit_targets )
        {
            return;
        }

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_SCANED )


        //===============//

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_STARTCLOCKS )

        p10_hcd_cache_startclocks(core_target);
        wrteei(1);

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_CLOCKED )

        //===============//

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_SCOMINIT )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_SCOM_INIT_ENABLE )
        {
#endif
            p10_hcd_cache_scominit(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        //===============//

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_SCOM_CUSTOMIZE )

        wrteei(0);

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_BLOCK_COPY_SCOM_ENABLE )
        {
#endif
            uint32_t l3HomerOffset = 0;
            uint32_t l3Length    = 0;

            for( uint32_t ec = 8; ec; ec = ( ec >> 1 ) )
            {
                if( G_qme_record.c_stop11_exit_targets & ec )
                {
                    G_qme_record.bce_buf_content_type  = SCOM_RESTORE;
                    l3HomerOffset = SCOM_RESTORE_CPMR_OFFSET + pQmeImgHdr->g_qme_coreL2ScomLength;
                    l3Length      = pQmeImgHdr->g_qme_L3ScomLength;

                    if( pQmeImgHdr->g_qme_magic_number >= SCOM_RESTORE_OPT_VER )
                    {
                        l3HomerOffset += (( pQmeImgHdr->g_qme_L3ScomLength >> 2 ) * get_core_pos( ec ));
                        l3Length       = l3Length >> 2; //Scom restore size per core
                    }

                    PK_TRACE("BCE Runtime Kickoff to Copy L3 Restore core");

                    qme_block_copy_core_data( QME_BCEBAR_0,
                                              ( l3HomerOffset >> 5),
                                              ( pQmeImgHdr->g_qme_scom_offset >> 5 ),
                                              ( pQmeImgHdr->g_qme_scom_length >> 5 ),
                                              ( l3Length >> 5) ); //32B blocks per core

                    PK_TRACE_DBG("BCE Runtime Check Scom Restore Copy Completed");

                    if( BLOCK_COPY_SUCCESS != qme_block_copy_check() )
                    {
                        PK_TRACE_DBG("ERROR: BCE L3 Scom Restore Copy Failed. HALT QME!");
                        QME_ERROR_HANDLER(QME_STOP_BLOCK_COPY_L3_SCOM_FAILED,
                                          pQmeImgHdr->g_qme_scom_offset,
                                          pQmeImgHdr->g_qme_L3ScomLength, ec);
                    }

                    if( G_qme_record.hcode_func_enabled & QME_HWP_SCOM_CUST_ENABLE )
                    {
                        core_scom_rest_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                                                static_cast<fapi2::MulticastCoreSelect>( ec ) );
                        p10_hcd_core_cache_scom_customize( core_scom_rest_target, CACHE_RESTORE_ENTRY );
                    }
                }
            }

#ifdef USE_HWP_ENABLE
        }

#endif

        wrteei(1);

        MARK_TAG( G_qme_record.c_stop11_exit_targets, SX_CACHE_SCOMED )

        //===============//

        G_qme_record.c_stop11_reached &= (~G_qme_record.c_stop11_exit_targets);
        //note, not reset stop11_exit_targets until stop11 scom restore is completed below

        uint32_t c_stop6 = G_qme_record.c_stop11_exit_targets & G_qme_record.c_cache_only_enabled;

        if( c_stop6 )
        {
            PK_TRACE_INF("WAKE6: Cache Only Cores[%x] Detected, hold them at this state", c_stop6);
            out32( QME_LCL_CORE_ADDR_WR( QME_SSH_SRC, c_stop6 ), SSH_ACT_LV6_COMPLETE );
            G_qme_record.c_stop11_exit_targets &= ~c_stop6;
            G_qme_record.c_stop5_exit_targets  &= ~c_stop6;
            G_qme_record.c_stop2_exit_targets  &= ~c_stop6;
        }
    }

    ///// [STOP5 EXIT] /////

    if( G_qme_record.c_stop5_exit_targets )
    {
        PK_TRACE_INF("WAKE5: Waking up Cores in STOP5[%x]", G_qme_record.c_stop5_exit_targets);

        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop5_exit_targets));

        //===============//

        MARK_TAG( G_qme_record.c_stop5_exit_targets, SX_CORE_POWERON )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_PFET_CTRL_ENABLE )
        {
#endif
            p10_hcd_core_poweron(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        //===============//

        MARK_TAG( G_qme_record.c_stop5_exit_targets, SX_CORE_RESET )

        wrteei(0);
        p10_hcd_core_reset(core_target);

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_SCANFLUSH_ENABLE )
        {
#endif
            p10_hcd_core_scan0(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        MARK_TAG( G_qme_record.c_stop5_exit_targets, SX_CORE_POWERED )

        //===============//

        MARK_TAG( G_qme_record.c_stop5_exit_targets, SX_CORE_GPTR_TIME_INITF )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_SCAN_INIT_ENABLE )
        {
#endif
            p10_hcd_core_gptr_time_initf(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        //===============//
        if( !G_qme_record.c_stop5_exit_targets )
        {
            return;
        }

        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop5_exit_targets));

        MARK_TAG( G_qme_record.c_stop5_exit_targets, SX_CORE_REPAIR_INITF )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_SCAN_INIT_ENABLE )
        {
#endif
            p10_hcd_core_repair_initf(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        //===============//
        if( !G_qme_record.c_stop5_exit_targets )
        {
            return;
        }

        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop5_exit_targets));

        MARK_TAG( G_qme_record.c_stop5_exit_targets, SX_CORE_ARRAYINIT )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_ARRAYINIT_ENABLE )
        {
#endif
            p10_hcd_core_arrayinit(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        if( !G_qme_record.c_stop5_exit_targets )
        {
            return;
        }

        //===============//

        MARK_TAG( G_qme_record.c_stop5_exit_targets, SX_CORE_INITF )

        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop5_exit_targets));

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_SCAN_INIT_ENABLE )
        {
#endif
            p10_hcd_core_initf(core_target);
#ifdef USE_HWP_ENABLE
        }

#endif

        if( !G_qme_record.c_stop5_exit_targets )
        {
            return;
        }

        wrteei(1);

        MARK_TAG( G_qme_record.c_stop5_exit_targets, SX_CORE_SCANED )
        //rest continue to stop2 exit

        //===============//

        // for forcing core shadow refresh
        // Per comments in p10_hcd_core_shadows_enable.C
        // which is the solo consumer of this attribute and only on QME Platform
        // therefore this is actually a qme bounded attribute,
        // which means it is defined at chip level to avoid multicast targets
        // but it is really meant to be used by local qme and local qme only,
        // in such scope, there is no concerns about other qmes and their cores
        // as they will have their own attribute container at local.
        // Note chip target scope at qme platform is not really a chip scope,
        // as this chip would only have one qme, which is the only local one.
        FAPI_TRY(FAPI_ATTR_SET(fapi2::ATTR_QME_STATE_LOSS_CORES, chip_target, G_qme_record.c_stop5_exit_targets));

        G_qme_record.c_stop5_reached &= (~G_qme_record.c_stop5_exit_targets);
    }

    ///// [STOP2 EXIT] /////

    if( G_qme_record.c_stop2_exit_targets )
    {
        PK_TRACE_INF("WAKE2: Waking up Cores in STOP2[%x]", G_qme_record.c_stop2_exit_targets);

        core_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                      static_cast<fapi2::MulticastCoreSelect>(G_qme_record.c_stop2_exit_targets));

        //===============//

        MARK_TAG( G_qme_record.c_stop2_exit_targets, SX_CORE_SKEWADJUST )

        wrteei(0);
        p10_hcd_core_startgrid(core_target);

        //===============//

        MARK_TAG( G_qme_record.c_stop2_exit_targets, SX_CORE_STARTCLOCKS )

        p10_hcd_core_startclocks(core_target);

        if( G_qme_record.mma_modes_enabled != MMA_POFF_DYNAMIC )
        {
            G_qme_record.c_mma_available |= G_qme_record.c_stop2_exit_targets;
        }

        wrteei(1);

        //===============//

        MARK_TAG( G_qme_record.c_stop2_exit_targets, SX_CORE_ENABLE_SHADOWS )

        c_not_eco = G_qme_record.c_stop2_exit_targets & (~G_qme_record.c_cache_only_enabled);

        if( c_not_eco )
        {
            core_not_eco = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                           static_cast<fapi2::MulticastCoreSelect>(c_not_eco));

            p10_hcd_core_shadows_enable(core_not_eco);
        }

        MARK_TAG( G_qme_record.c_stop2_exit_targets, SX_CORE_CLOCKED )
    }

    ///// [STOP5/11 EXIT SCOM] /////

    G_qme_record.c_stop2p_exit_targets = G_qme_record.c_stop11_exit_targets | G_qme_record.c_stop5_exit_targets;

    if( G_qme_record.c_stop2p_exit_targets )
    {
        PK_TRACE_INF("WAKE5/11: Scominit Cores[%x] in STOP5[%x]/11[%x], ECO Cores[%x]",
                     G_qme_record.c_stop2p_exit_targets,
                     G_qme_record.c_stop5_exit_targets,
                     G_qme_record.c_stop11_exit_targets,
                     G_qme_record.c_cache_only_enabled);

        //===============//

        MARK_TAG( G_qme_record.c_stop2p_exit_targets, SX_CORE_SCOMINIT )

#ifdef USE_HWP_ENABLE

        if( G_qme_record.hcode_func_enabled & QME_HWP_SCOM_INIT_ENABLE )
        {
#endif

            c_not_eco = G_qme_record.c_stop2p_exit_targets & (~G_qme_record.c_cache_only_enabled);

            if( c_not_eco )
            {
                core_not_eco = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                               static_cast<fapi2::MulticastCoreSelect>(c_not_eco));

                PK_TRACE("Debug1: c_not_eco %x stop2p %x eco %x",
                         c_not_eco,
                         G_qme_record.c_stop2p_exit_targets,
                         G_qme_record.c_cache_only_enabled);

                p10_hcd_core_scominit(core_not_eco);
            }

#ifdef USE_HWP_ENABLE
        }

#endif

        //===============//

        //In order to allow for cores to special wake-ups in the presence of a system xstop
        //  Upon a STOP 11 Exit, if EINR.SYSTEM_CHECKSTOP is assert,
        //  skip SCOM restore, skip SELF restore
        //  set QME LFIR[35](spare) as "STOP 11 special wake-up in xstop"
        //  set special wakeup done
        if( in32( QME_LCL_EINR ) & BIT32(2) )
        {
            G_qme_record.hcode_func_enabled &= ~QME_HWP_SCOM_CUST_ENABLE;
            G_qme_record.hcode_func_enabled &= ~QME_SELF_RESTORE_ENABLE;

            if (!G_IsSimics)
            {
                out64(QME_LCL_LFIR_OR, BIT64(35)); //has to be 64B with LFIR
            }

            G_qme_record.c_special_wakeup_exit_pending = 0xF;
        }

        MARK_TAG( G_qme_record.c_stop2p_exit_targets, SX_CORE_SCOM_CUSTOMIZE )

        wrteei(0);

        if( G_qme_record.hcode_func_enabled & QME_BLOCK_COPY_SCOM_ENABLE )
        {
            G_qme_record.bce_buf_content_type  = SCOM_RESTORE;
            uint32_t l2HomerOffet = 0;
            uint32_t l2Length    = 0;

            for( uint32_t ec = 8; ec; ec = ( ec >> 1 ) )
            {
                if( G_qme_record.c_stop2p_exit_targets & ec )
                {
                    l2HomerOffet  =  0;
                    l2Length      =  pQmeImgHdr->g_qme_coreL2ScomLength;

                    if( pQmeImgHdr->g_qme_magic_number >= SCOM_RESTORE_OPT_VER )
                    {
                        l2HomerOffet  =  ( ( pQmeImgHdr->g_qme_coreL2ScomLength >> 2 ) * get_core_pos( ec ) );
                        l2Length      =  l2Length >> 2;
                    }

                    l2HomerOffet += SCOM_RESTORE_CPMR_OFFSET;

                    PK_TRACE("BCE Runtime Kickoff to Copy Core Scom Restore");

                    qme_block_copy_core_data( QME_BCEBAR_0,
                                              ( l2HomerOffet >> 5 ),
                                              ( pQmeImgHdr->g_qme_scom_offset >> 5 ),
                                              ( pQmeImgHdr->g_qme_scom_length >> 5 ),
                                              ( l2Length >> 5 ) ); //32B blocks of per core entry

                    PK_TRACE_DBG("BCE Runtime Check Scom Restore Copy Completed");

                    if( BLOCK_COPY_SUCCESS != qme_block_copy_check() )
                    {
                        PK_TRACE_DBG("ERROR: BCE CL2 Scom Restore Copy Failed. HALT QME!");

                        QME_ERROR_HANDLER(QME_STOP_BLOCK_COPY_CL2_SCOM_FAILED,
                                          pQmeImgHdr->g_qme_scom_offset,
                                          pQmeImgHdr->g_qme_coreL2ScomLength, ec);
                    }

                    if( G_qme_record.hcode_func_enabled & QME_HWP_SCOM_CUST_ENABLE )
                    {
                        core_scom_rest_target = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                                                static_cast<fapi2::MulticastCoreSelect>( ec ) );
                        p10_hcd_core_cache_scom_customize( core_scom_rest_target, CORE_RESTORE_ENTRY );
                    }
                } //if( G_qme_record.c_stop11_exit_targets & ec )
            } //for( uint32_t ec = 8;
        } // if( G_qme_record.hcode_func_enabled

        wrteei(1);

        MARK_TAG( G_qme_record.c_stop2p_exit_targets, SX_CORE_SCOMED )

        //===============//

        G_qme_record.c_stop11_exit_targets = 0;
        G_qme_record.c_stop5_exit_targets  = 0;
    }

    //Core is not going to do self restore if in cache_only mode
    G_qme_record.c_stop2p_exit_targets &= ~G_qme_record.c_cache_only_enabled;

    if( G_qme_record.c_stop2p_exit_targets )
    {
        MARK_TAG( G_qme_record.c_stop2p_exit_targets, SX_CORE_SELF_RESTORE )

        if( G_qme_record.hcode_func_enabled & QME_SELF_RESTORE_ENABLE )
        {
            PK_TRACE_INF("WAKE11: self restore STOP5/11[%x] Cache only Cores[%x] 0x%08x",
                         G_qme_record.c_stop2p_exit_targets,
                         G_qme_record.c_cache_only_enabled,
                         G_qme_record.hcode_func_enabled);

            qme_stop_self_execute(G_qme_record.c_stop2p_exit_targets, SPR_SELF_RESTORE);
        }

        MARK_TAG( G_qme_record.c_stop2p_exit_targets, SX_CORE_SRESET_THREADS )

        if( G_qme_record.hcode_func_enabled & QME_SELF_RESTORE_ENABLE )
        {
            qme_stop_self_complete(G_qme_record.c_stop2p_exit_targets, SPR_SELF_RESTORE);

            G_qme_record.c_stop2p_exit_targets &= ~G_qme_record.c_self_failed;

            if( G_qme_record.c_stop2p_exit_targets == 0 )
            {
                return;
            }
        }

        MARK_TAG( G_qme_record.c_stop2p_exit_targets, SX_CORE_RESTORED )

        //===============//

        G_qme_record.c_stop2p_exit_targets = 0;
    }

    ///// [STOP0 WAKEUP] /////

    if( G_qme_record.c_stop2_exit_targets )
    {
        PK_TRACE_INF("WAKE0: Waking up Cores in STOP0[%x], ECO Cores[%x]",
                     G_qme_record.c_stop2_exit_targets,
                     G_qme_record.c_cache_only_enabled);

        //===============//

        MARK_TAG( G_qme_record.c_stop2_exit_targets, SX_CORE_HANDOFF_PC )

        c_not_eco = G_qme_record.c_stop2_exit_targets & (~G_qme_record.c_cache_only_enabled);

        if( c_not_eco )
        {
            core_not_eco = chip_target.getMulticast<fapi2::MULTICAST_AND>(fapi2::MCGROUP_GOOD_EQ,
                           static_cast<fapi2::MulticastCoreSelect>(c_not_eco));

            PK_TRACE("Debug2: c_not_eco %x stop2 %x eco %x",
                     c_not_eco,
                     G_qme_record.c_stop2_exit_targets,
                     G_qme_record.c_cache_only_enabled);

            // HW534619 DD1 workaround move to after self restore
            p10_hcd_core_timefac_to_pc(core_not_eco);
        }

        //===============//

        qme_stop_report_pls_srr1(G_qme_record.c_stop2_exit_targets);

        qme_stop_handoff_pc(G_qme_record.c_stop2_exit_targets,
                            G_qme_record.c_special_wakeup_exit_pending);

        MARK_TAG( G_qme_record.c_stop2_exit_targets, SX_CORE_AWAKE )

        //===============//

        G_qme_record.c_stop2_reached &= ~G_qme_record.c_stop2_exit_targets;
        G_qme_record.c_stop2_exit_targets = 0;
    }
}
